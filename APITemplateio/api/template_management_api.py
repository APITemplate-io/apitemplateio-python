# coding: utf-8

"""
    APITemplate.io API Reference

    # Introduction   Welcome to the [APITemplate.io](https://apitemplate.io) API v2!  APITemplate.io provides PDF generation services including [Template-based PDF generation](https://apitemplate.io/pdf-generation-api/), [HTML to PDF](https://apitemplate.io/html-to-pdf-api/), and [URL to PDF conversions](https://apitemplate.io/create-pdf-from-url/), as well as an [image generation API](https://apitemplate.io/image-generation-api/).  This page contains the documentation on how to use APITemplate.io through API calls. With the APITemplate.io API, you can create PDF documents and images, as well as manage your templates.  Our API is built on RESTful HTTP, so you can utilize any HTTP/REST library of your choice in your preferred programming language to interact with APITemplate.io's API.  **Steps to produce PDFs/Images** 1. Design your template(s) using our intuitive drag-and-drop template editor or the HTML editor and save it. 2. Integrate your workflow, either with platforms like Zapier, Make.com/Integromat, Bubble.io, or any programming languages that support REST API, to send us the JSON data along with the template ID/URL/or HTML content. 3. Our REST API will then return a download URL for the images (in PNG and JPEG formats) or PDFs.  # Authentication Upon signing up for an account, an API key will be generated for you. If needed, you can reset this API key via the web console (under the \"API Integration\" section).  To integrate with our services, you need to authenticate with the APITemplate.io API. Provide your secret key in the request header using the X-API-KEY field.   # Content Type and CORS  **Request Content-Type** The Content-Type for POST and GET requests is set to application/json.  **Cross-Origin Resource Sharing** This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with  [W3C spec](https://www.w3.org/TR/cors/). And that allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site.    # Regional API endpoint(s) A regional API endpoint is intended for customers in the same region. The data for the request and generated PDFs/images are processed and stored within the region.  The regions are:  | Region               | Endpoint                            | Max Timeout (Seconds) | Max Payload Size(MB)** | |----------------------|-------------------------------------|-----------------------|-------------------------| | Default (Singapore)  | https://rest.apitemplate.io         | 100                   | 1                       | | Europe (Frankfurt)   | https://rest-de.apitemplate.io      | 100                   | 1                       | | US East (N. Virginia)| https://rest-us.apitemplate.io      | 100                   | 1                       | | Australia (Sydney)   | https://rest-au.apitemplate.io      | 30                    | 6                       |   Alternative Regions: | Region               | Endpoint                            | Max Timeout (Seconds) | Max Payload Size(MB)** | |----------------------|-------------------------------------|-----------------------|-------------------------| | Default (Singapore)  | https://rest-alt.apitemplate.io     | 30                    | 6                       | | Europe (Frankfurt)   | https://rest-alt-de.apitemplate.io  | 30                    | 6                       | | US East (N. Virginia)| https://rest-alt-us.apitemplate.io  | 30                    | 6                       |  ** Note: - Payload size applies to request and response - If \"export_type\" is set to `json` which output file that on AWS S3 doesn't have the limitation - If the \"export_type\" is set to `file` which returns binary data of the generated PDF, the file size of the generated PDF is limited to either 6MB or 1MB based on the region    Other regions are available on request, contact us at hello@apitemplate.io for more information  # Rate limiting Our API endpoints use IP-based rate limiting to ensure fair usage and prevent abuse. Users are allowed to make up to **100 requests per 10 seconds**. This rate limit is designed to accommodate a reasonable volume of requests while maintaining optimal performance for all users.  However, if you exceed this limit and make additional requests, you will receive a response with HTTP code 429. This status code indicates that you have reached the rate limit and need to wait before making further requests. 

    The version of the OpenAPI document: Version 2.0
    Contact: hello@apitemplate.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictStr

from typing import Optional

from APITemplateio.models.response_success import ResponseSuccess
from APITemplateio.models.response_success_list_templates import ResponseSuccessListTemplates
from APITemplateio.models.response_success_template import ResponseSuccessTemplate
from APITemplateio.models.update_template_request import UpdateTemplateRequest

from APITemplateio.api_client import ApiClient
from APITemplateio.api_response import ApiResponse
from APITemplateio.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class TemplateManagementApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def get_template(self, template_id : Annotated[Optional[StrictStr], Field(description="Your template id, it can be obtained in the web console(Manage Templates)")] = None, **kwargs) -> ResponseSuccessTemplate:  # noqa: E501
        """Get PDF template  # noqa: E501

        Retrieves information of the PDF template (**This is an experimental API, contact support to learn more**)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_template(template_id, async_req=True)
        >>> result = thread.get()

        :param template_id: Your template id, it can be obtained in the web console(Manage Templates)
        :type template_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSuccessTemplate
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_template_with_http_info(template_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_template_with_http_info(self, template_id : Annotated[Optional[StrictStr], Field(description="Your template id, it can be obtained in the web console(Manage Templates)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get PDF template  # noqa: E501

        Retrieves information of the PDF template (**This is an experimental API, contact support to learn more**)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_template_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param template_id: Your template id, it can be obtained in the web console(Manage Templates)
        :type template_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSuccessTemplate, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'template_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_template" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('template_id') is not None:  # noqa: E501
            _query_params.append(('template_id', _params['template_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKeyAuth']  # noqa: E501

        _response_types_map = {
            '200': "ResponseSuccessTemplate",
        }

        return self.api_client.call_api(
            '/v2/get-template', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_templates(self, limit : Annotated[Optional[StrictStr], Field(description="Retrieve only the number of records specified. Default to 300")] = None, offset : Annotated[Optional[StrictStr], Field(description="Offset is used to skip the number of records from the results. Default to 0")] = None, format : Annotated[Optional[StrictStr], Field(description="To filter the templates by either 'PDF' or 'JPEG'")] = None, template_id : Annotated[Optional[StrictStr], Field(description="To filter the templates by template id")] = None, group_name : Annotated[Optional[StrictStr], Field(description="To filter the templates by the group name")] = None, with_layer_info : Annotated[Optional[StrictStr], Field(description="Return along with layer information for image templates, 0=false , 1=true. Default to '0'")] = None, **kwargs) -> ResponseSuccessListTemplates:  # noqa: E501
        """List Templates  # noqa: E501

        Retrieves the information of templates   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_templates(limit, offset, format, template_id, group_name, with_layer_info, async_req=True)
        >>> result = thread.get()

        :param limit: Retrieve only the number of records specified. Default to 300
        :type limit: str
        :param offset: Offset is used to skip the number of records from the results. Default to 0
        :type offset: str
        :param format: To filter the templates by either 'PDF' or 'JPEG'
        :type format: str
        :param template_id: To filter the templates by template id
        :type template_id: str
        :param group_name: To filter the templates by the group name
        :type group_name: str
        :param with_layer_info: Return along with layer information for image templates, 0=false , 1=true. Default to '0'
        :type with_layer_info: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSuccessListTemplates
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_templates_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_templates_with_http_info(limit, offset, format, template_id, group_name, with_layer_info, **kwargs)  # noqa: E501

    @validate_arguments
    def list_templates_with_http_info(self, limit : Annotated[Optional[StrictStr], Field(description="Retrieve only the number of records specified. Default to 300")] = None, offset : Annotated[Optional[StrictStr], Field(description="Offset is used to skip the number of records from the results. Default to 0")] = None, format : Annotated[Optional[StrictStr], Field(description="To filter the templates by either 'PDF' or 'JPEG'")] = None, template_id : Annotated[Optional[StrictStr], Field(description="To filter the templates by template id")] = None, group_name : Annotated[Optional[StrictStr], Field(description="To filter the templates by the group name")] = None, with_layer_info : Annotated[Optional[StrictStr], Field(description="Return along with layer information for image templates, 0=false , 1=true. Default to '0'")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Templates  # noqa: E501

        Retrieves the information of templates   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_templates_with_http_info(limit, offset, format, template_id, group_name, with_layer_info, async_req=True)
        >>> result = thread.get()

        :param limit: Retrieve only the number of records specified. Default to 300
        :type limit: str
        :param offset: Offset is used to skip the number of records from the results. Default to 0
        :type offset: str
        :param format: To filter the templates by either 'PDF' or 'JPEG'
        :type format: str
        :param template_id: To filter the templates by template id
        :type template_id: str
        :param group_name: To filter the templates by the group name
        :type group_name: str
        :param with_layer_info: Return along with layer information for image templates, 0=false , 1=true. Default to '0'
        :type with_layer_info: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSuccessListTemplates, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'limit',
            'offset',
            'format',
            'template_id',
            'group_name',
            'with_layer_info'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_templates" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        if _params.get('template_id') is not None:  # noqa: E501
            _query_params.append(('template_id', _params['template_id']))

        if _params.get('group_name') is not None:  # noqa: E501
            _query_params.append(('group_name', _params['group_name']))

        if _params.get('with_layer_info') is not None:  # noqa: E501
            _query_params.append(('with_layer_info', _params['with_layer_info']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKeyAuth']  # noqa: E501

        _response_types_map = {
            '200': "ResponseSuccessListTemplates",
        }

        return self.api_client.call_api(
            '/v2/list-templates', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_template(self, update_template_request : UpdateTemplateRequest, **kwargs) -> ResponseSuccess:  # noqa: E501
        """Update PDF Template  # noqa: E501

        This endpoint updates PDF template (**This is an experimental API, contact support to learn more**)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_template(update_template_request, async_req=True)
        >>> result = thread.get()

        :param update_template_request: (required)
        :type update_template_request: UpdateTemplateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSuccess
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_template_with_http_info(update_template_request, **kwargs)  # noqa: E501

    @validate_arguments
    def update_template_with_http_info(self, update_template_request : UpdateTemplateRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Update PDF Template  # noqa: E501

        This endpoint updates PDF template (**This is an experimental API, contact support to learn more**)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_template_with_http_info(update_template_request, async_req=True)
        >>> result = thread.get()

        :param update_template_request: (required)
        :type update_template_request: UpdateTemplateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSuccess, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'update_template_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_template" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_template_request'] is not None:
            _body_params = _params['update_template_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKeyAuth']  # noqa: E501

        _response_types_map = {
            '200': "ResponseSuccess",
        }

        return self.api_client.call_api(
            '/v2/update-template', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
